<h2 style="color:#E91E63;">Lessons Learned</h2>

<ol style="color:#E91E63; font-size:18px; line-height:1.6;">

1. The importance of defining clear product requirements early. We learned that without firm requirements, design decisions quickly become scattered and subjective. Establishing measurable needs for sensing, power, communication, and durability helped guide all later choices and kept the project focused.
2. How essential it is to validate component compatibility before purchasing. Through design review feedback, we realized that voltage levels, communication protocols, and current limits must be checked together, not separately. This prevented incorrect part selection and ensured smooth integration on the final PCB.
3. The value of building a well-structured block diagram. We learned that a block diagram is more than a class assignment—it clarifies power flow, communication lines, and responsibilities across subsystems. This visualization helped us identify missing elements early, such as keep-out zones for antennas and multiple I²C addresses.
4. How to organize a communication protocol that satisfies both user needs and system reliability. Through UML sequence diagrams, we learned how timing, acknowledgments, and simple message formats improve system robustness and reduce ambiguity during wireless communication.
5. That power budgeting must be done conservatively. We discovered that using worst-case current values and adding safety margins is critical for ensuring that the regulator and battery can sustain peak load. This prevented issues like brownouts, thermal overload, and regulator underspecification.
6. The importance of modular team responsibilities. Dividing the project into sensing, actuation/output, communication, and microcontroller subsystems allowed each team member to specialize. This structure improved accountability and made integration far smoother than working in one large undivided group.
7. The need to iterate on the concept design based on feasibility. While early sketches included many features, we learned to scale back to what could realistically be implemented within time, cost, and component constraints. Feedback helped us refine the number of sensors, simplify enclosures, and adopt a weather-station-style layout.
8. How field conditions shape engineering decisions. We gained a better understanding of how durability, enclosure design, weatherproofing, and wildfire-zone constraints dictate sensor placement and housing materials. This shifted our design from theoretical to practical and deployable.
9. The importance of clear and consistent message structures in software. We learned that even small inconsistencies in message formatting can break communication. Standardizing field order, data types, and error handling significantly improved the communication diagrams and made the system easier to debug.
10. The value of continuous feedback and design reviews. Design reviews helped us identify weaknesses early, including missing safety factors, unclear architecture, and unrealistic expectations. Incorporating this feedback made our design more professional, technically defensible, and aligned with industry expectations.

## Top 5 Recommendations for Future Students

1. Start learning basic embedded programming skills. Especially Arduino or ESP32 development, because having a foundation in microcontroller coding will make the project workload much easier to manage.
2. Familiarize yourself with reading electronic component datasheets early, since understanding pinouts, voltage requirements, and communication protocols becomes essential for selecting parts and designing your schematics.
3. Practice soldering and basic electronics assembly ahead of time, as hands-on skills are critical and will save you from mistakes and delays during prototype construction.
4. Learn how to use GitHub properly. Including repositories, commits, branches, and Markdown, because documentation and code organization are major parts of the course.
5. Manage your time intentionally by breaking the project into weekly goals, since waiting until the last minute quickly leads to burnout and prevents the team from completing a functional prototype.

## Version 2.0 Communication A Architecture Design

If we were to develop a Version 2.0 of our communication architecture, several improvements could be made to increase reliability, expand functionality, and make the system easier to debug and maintain. Our current design uses ESP-NOW to send sensor data between devices, which works well for short-range broadcasts but has limitations when scaling, logging, or integrating with external systems. In a Version 2.0 system, we would move toward a more structured and modular communication architecture that supports multiple message types, error detection, and long-term data handling. This would allow our weather-station network to operate more reliably in remote wildfire-prone areas where consistent communication and robustness are essential.
One of the first improvements would be implementing a more organized message structure. Currently, our messages send raw sensor data in a simple format. A Version 2.0 system would incorporate message headers, device IDs, timestamps, and CRC checksums for error detection. This makes the architecture more scalable and easier to decode, especially if many devices broadcast simultaneously. We would also divide our software into clearer modules—such as sensing, message formatting, transmission, reception, and data handling—so that each subsystem operates independently. This modularity would support easier debugging and allow individual components to be upgraded without affecting the entire system.
Improving debuggability would be a high priority. Version 2.0 would include serial logging, an internal testing mode, and LED indicators tied to communication status (successful send, failure, pairing issues). These additions would help quickly identify communication faults in the field. Additionally, we could implement a communication watchdog timer to reset the wireless subsystem if data is not transmitted or received within a specified window. Features like these increase the system’s robustness and reduce the chance of undetected failures during a wildfire event.
We would also expand the communication protocol to support new functions such as acknowledgments (ACKs), retransmission on failure, and possibly queued data packets for situations where communication temporarily drops. For long-term improvements, Version 2.0 could integrate LoRa or cellular IoT as an optional long-range communication method. In remote wildfire environments, ESP-NOW may not cover the required distance between station nodes, and long-range communication could significantly improve system reliability.
Version 2.0 would include better system-level organization. We would separate sensor polling intervals from communication intervals so that the device does not waste energy transmitting too often. We would also expand protocol support to include versioning—ensuring that future sensors or nodes remain compatible with older units. Through these improvements, Version 2.0 of our communication architecture would become more stable, reliable, and scalable, ultimately enabling a more effective wildfire-prevention early-warning network.
